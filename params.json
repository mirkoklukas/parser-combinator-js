{"name":"Parser-combinator-js","tagline":"A Javascript implementation of the monadic parser combinators defined by G. Hutton and E. Meijer.","body":"# Monadic parsing in JavaScript\r\n\r\nA Javascript implementation of (some of) the *monadic parser combinators* defined by G. Hutton and E. Meijer (cf. [1], see below).\r\n\r\nYou can see the combinators in action here (the combinators are used to define the parsing function): <a href=\"http://mirkoklukas.github.io/parser-combinator-js/demo/\">Lisp interpreter</a>\r\n\r\n[1] G. Hutton and E. Meijer, *Monadic parsing in Haskell*, Journal of Functional Programming **8**, Cambridge University Press (1998), 437â€“444.\r\n\r\n\r\n## What is it\r\n\r\nA **(monadic) parser combinator** is a higher-order functions that produces, and serves as building block for a more specific *parser*. In our context a **parser** can be understood as a funcion that takes a `string` and returns a list of tuples `[(a,string), ...,(a,string)]` of some data type `a` and another `string`. The first component of the tupel can be understood as the result of the parser (e.g. another string, a single character, or a abstract synthax tree), whereas the second component is the remaining string (i.e. the part of the string that hasn't yet been \"consumend\" by the parser). The empty list `[]` indicates a failed approach of parsing the given string. The term *monadic* refers to the fact that we can endow the the set of parsers with an additional structure -- we'll dive into that later.\r\n\r\n**Examples**. Here is a simple parsing function that simply consumes the letter \"x\":\r\n```JavaScript\r\nvar x = function (string) {\r\n  var first = string.charAt(0),\r\n      rest  = string.slice(1);\r\n  if (first === \"x\") return [[\"x\", rest]];\r\n  else return [];\r\n}\r\n\r\nx(\"xyz\"); // [[\"x\", \"yz\"]] \r\nx(\"zyx\"); // [] \r\n\r\n```\r\n\r\n...\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}